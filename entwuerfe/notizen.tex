\documentclass{article}
\usepackage[latin1]{isolatin}
\usepackage{latexsym}
\usepackage[german]{babel}
\usepackage[a4paper]{geometry}
\geometry{textwidth=18cm, textheight=24cm} 
\parindent0em
\pagenumbering{arabic}
\begin{document}

\section*{Pastry}

\begin{itemize}

\item KnotenIDs zwischen 0 und $2^{128}-1$ (zufällig generiert)
\item Message wird an Knoten weitergeleitet, dessen KnotenID am dichtesten an Message-hash-value liegt
\item Jeder Knoten speichert Routing-tabel, Neighbourhood-set, Leaf-set
\item aufgrund einer Nachbarschaftsmetrik werden Nachrichten an den nahegelegensten Knoten unter denen aus den Tabellen in Frage kommenden Knoten gesendet

\end{itemize}

\section*{Scribe}
\begin{itemize}
\item scalable group communication-system (PubSub) built on top of Pastry
\item each group has a 160bit groupID
\item nodes which subscribe to a group, form a multicast-tree, nodeID of the root-node (Broker) is numerically closest to topicID 
\end{itemize}

\section*{FeedTree}
\begin{itemize}
\item a micronews distribution-system
\item uses p2p-overlay network to distribute RSS-feeds
\item peers in network share bandwith costs $\rightarrow$ reduces load on provider
\item distribution via Scribe
\end{itemize}

\section*{TMTP}
\begin{itemize}
\item Tree-based Multicast Transport Protocol
\item designed for efficient delivery of messages to nodes dynamically joining and leaving the network
\item group-leaders are organized in a hierarchical tree
\item group-members are as well organized in a hierarchical tree (subnet/domain)
\item Transmission rate controlled by sliding window based protocol
\item packets are sent only to direct children
\item children multicast NACK in combination with nack supression when missing packets are detected
\item parent sends packet again (multicast) with TTL
\item multicast sending and suppression of nacks reduces number of nacks
\item ACKs are sent directly and immediately to the parent after receiving packet
\item periodic positive ACKs ensure reliability of children
\item retransmission timers ensure receive of packets
\item two timers for retransmitting: $T_{retrans}$: after expiring packets will be resend; $T_{ack}$: after expiring ACK will be sent
\item this helps to reduce resending of packets if ACKs are lost

\end{itemize}
\newpage
\section*{Algorithmus zur Koordination der Broker bezüglich des Pollings der Publisher}
Zunächst muss gesagt werden, dass es grundsätzlich nicht möglich ist, eine gleichzeitige Aktualisierung und Verbreitung der RSS-Feeds seitens der
Broker zum
Zeitpunkt der Aktualisierung seitens der Publisher zu erreichen, da zu keinem Zeitpunkt ermittelt werden kann, wann genau die nächste Aktualisierung
durch die Publisher erfolgen wird. Es kann nur versucht werden, sich diesem Verhalten anzunähern. Je kürzer das Poll-Intervall desto kleiner die maximale
Zeitspanne zwischen
Aktualisierung und nächstem Polling. Eine sehr kurze Zeitspanne zwischen zwei Polls würde aber ein hohes Netzaufkommen bedeuten
(erst recht bei voneinander unabhängigem Pollen der Broker), was nicht wünschenswert ist. Es sollte deshalb versucht werden,
das Polling der Broker aufeinander abzustimmen und ein angemessenes Poll-Intervall zu erreichen.
\subsection*{Beschreibung des Algorithmus}
{\bf Voraussetzung:} RSS-Feeds sollten das Tag ``lastBuildDate'' unterstützen und ein Tag, welches Auskunft über ein minimales Update-Intervall 
(z.B. ``minUpdateInterval'') liefert.
Das minimale Update-Intervall sagt aus, welche Zeitspanne mindestens vergehen muss, bevor eine neue Aktualisierung der Feeds erfolgt.\\

Bei diesem Algorithmus soll erreicht werden, dass verhältnismäßig möglichst
wenige Publisher eine gleichzeitige Aktualisierung der Feeds vornehmen. Die neuen Feeds werden dann den Brokern über das Netzwerk übersand.\\
Notwendig ist pro Publisher ein Poll-Timer, der bestimmt, wann das nächste Polling zu erfolgen hat. Ist dieser Timer abgelaufen, erfragt der Publisher beim
RSS-Server den aktuellen Feed. Ist dieser nicht neuer als der bisher beim Publisher vorhandene Feed, wird lediglich der Poll-Timer neu gesetzt (s.u.).
Ist der neue Feed hingegen aktueller, wird sowohl der Poll-Timer neu gesetzt als auch dieser neue Feed dem Nachbarbroker entsprechend den vorhandenen
Filterregeln übersand; jeder Nachbarbroker leitet seinerseits diesen neuen Feed an die jeweiligen Nachbarbroker weiter,
falls der Feed hier ebenfalls aktueller ist als der bisherige. Allerdings
wird der Poll-Timer nur in diesem Fall neu gesetzt. Das setzen des Poll-Timers geschieht folgendermaßen: Aus ``lastBuildDate'' und ``minUpdateInterval''
wird die ungefähre Zeitspanne ``nextAktualisation'' zur nächsten Aktualisierung durch den Publisher berechnet. Für den Wert des Poll-Timers $pt$ soll
nun gelten: $nextAktualisation \leq pt \leq 2*nextAktualisation$. $pt$ wird in diesem Bereich zufällig gewählt. Somit sollte es relativ wenige Publisher
geben, die gleichzeitig den aktuellen Stand beim RSS-Server erfragen. Nach erfolgreicher Aktualisierung wird mit hoher Wahrscheinlichkeit ein anderer
Publisher den Stand beim nächsten Mal erfragen. Außerdem ist gewährleistet, dass bei hoher Publisheranzahl der RSS-Server nach Ablauf der Poll-Timer
in regelmäßigen Abständen kontaktiert wird, falls zu diesem Zeitpunkt noch keine Aktualisierung vorlag.\\
Tritt ein neuer Knoten dem Netzwerk bei, so wird dieser den aktuellen Stand bei seinem nächsten Nachbarn erfragen.\\

Beobachtungen der Simulation:
\begin{itemize}
\item Anfrageverteilung und -intervall hängen von zwei Faktoren ab: Subscriber-TTL und Skalierungsfaktor
\item Um Skalierung des Netzes zu erreichen, müssen diese Parameter angepasst werden
\end{itemize}
Weitere Ideen:
\begin{itemize}
\item Skalierungsfaktor muss an Subscriberanzahl angepasst werden
\item Subscriber-TTL muss an tatsächliches momentanes Aktualisierungsintervall des RSS-Servers angepasst werden
\end{itemize}

Ermittlung der Subscriberanzahl:\\
Broker bestimmen die Netzgröße: Netzgröße bestimmt sich aus Summe aller Teilnetze plus Anzahl der eigenen Subscriber. Größe des Teilnetzes wird an
die entsprechenden Nachbarbroker übersendet: Gesamtgröße - Teilnetzgröße des Nachbarbrokers. In regelmäßigen Zeitabständen (Aktualisierungstimer -pro
Nachbarbroker) wird eine Aktualsisierung der
Teilnetzgröße an die Nachbarbroker übersand. Diese antworten mit einer Bestätigung. Wird nach einer gewissen Zeitspanne keine Bestätigung
(Bestätigungstimer) erhalten, gilt das Teilnetz als abgekoppelt. Ein Broker, der von einem Nachbarbroker ein Aktualisierung erhält, terminiert bestehende
Aktualisierungs- und Bestätigungstimer für diesen Nachbarbroker.
\end{document}
