\documentclass{article}
\usepackage{isolatin1}
\usepackage{latexsym}
\usepackage[german]{babel}
\usepackage[a4paper]{geometry}
\geometry{textwidth=18cm, textheight=24cm} 
\parindent0em
\pagenumbering{arabic}
\begin{document}

\section*{Pastry}

\begin{itemize}

\item KnotenIDs zwischen 0 und $2^{128}-1$ (zufällig generiert)
\item Message wird an Knoten weitergeleitet, dessen KnotenID am dichtesten an Message-hash-value liegt
\item Jeder Knoten speichert Routing-tabel, Neighbourhood-set, Leaf-set
\item aufgrund einer Nachbarschaftsmetrik werden Nachrichten an den nahegelegensten Knoten unter denen aus den Tabellen in Frage kommenden Knoten gesendet

\end{itemize}

\section*{Scribe}
\begin{itemize}
\item scalable group communication-system (PubSub) built on top of Pastry
\item each group has a 160bit groupID
\item nodes which subscribe to a group, form a multicast-tree, nodeID of the root-node (Broker) is numerically closest to topicID 
\end{itemize}

\section*{FeedTree}
\begin{itemize}
\item a micronews distribution-system
\item uses p2p-overlay network to distribute RSS-feeds
\item peers in network share bandwith costs $\rightarrow$ reduces load on provider
\item distribution via Scribe
\end{itemize}

\section*{TMTP}
\begin{itemize}
\item Tree-based Multicast Transport Protocol
\item designed for efficient delivery of messages to nodes dynamically joining and leaving the network
\item group-leaders are organized in a hierarchical tree
\item group-members are as well organized in a hierarchical tree (subnet/domain)
\item Transmission rate controlled by sliding window based protocol
\item packets are sent only to direct children
\item children multicast NACK in combination with nack supression when missing packets are detected
\item parent sends packet again (multicast) with TTL
\item multicast sending and suppression of nacks reduces number of nacks
\item ACKs are sent directly and immediately to the parent after receiving packet
\item periodic positive ACKs ensure reliability of children
\item retransmission timers ensure receive of packets
\item two timers for retransmitting: $T_{retrans}$: after expiring packets will be resend; $T_{ack}$: after expiring ACK will be sent
\item this helps to reduce resending of packets if ACKs are lost

\end{itemize}
\newpage
\section*{Algorithmus zur Koordination der Broker bezüglich des Pollings der Publisher}
Zunächst muss gesagt werden, dass es grundsätzlich nicht möglich ist, eine gleichzeitige Aktualisierung und Verbreitung der RSS-Feeds seitens der
Broker zum
Zeitpunkt der Aktualisierung seitens der Publisher zu erreichen, da zu keinem Zeitpunkt ermittelt werden kann, wann genau die nächste Aktualisierung
durch die Publisher erfolgen wird. Es kann nur versucht werden, sich diesem Verhalten anzunähern. Je kürzer das Poll-Intervall desto kleiner die maximale
Zeitspanne zwischen
Aktualisierung und nächstem Polling. Eine sehr kurze Zeitspanne zwischen zwei Polls würde aber ein hohes Netzaufkommen bedeuten
(erst recht bei voneinander unabhängigem Pollen der Broker), was nicht wünschenswert ist. Es sollte deshalb versucht werden,
das Polling der Broker aufeinander abzustimmen und ein angemessenes Poll-Intervall zu erreichen.
\subsection*{Beschreibung des Algorithmus}
{\bf Voraussetzung:} RSS-Feeds sollten das Tag ``lastBuildDate'' unterstützen und ein Tag, welches Auskunft über ein minimales Update-Intervall 
(z.B. ``minUpdateInterval'') liefert.
Das minimale Update-Intervall sagt aus, welche Zeitspanne mindestens vergehen muss, bevor eine neue Aktualisierung der Feeds erfolgt.\\

Bei diesem Algorithmus soll erreicht werden, dass möglichst verhältnismäßig
wenige Broker eine gleichzeitige Aktualisierung der Feeds vornehmen. Die neuen Feeds werden dann den übrigen Brokern über das Netzwerk übersand.\\
Notwendig ist pro Broker ein Poll-Timer, der bestimmt, wann das nächste Polling zu erfolgen hat. Ist dieser Timer abgelaufen, erfragt der Broker beim
Publisher den aktuellen Feed. Ist dieser nicht neuer als der bisherige beim Broker vorhandene Feed, wird lediglich der Poll-Timer neu gesetzt (s.u.).
Ist der neue Feed hingegen aktueller, wird sowohl der Poll-Timer neu gesetzt als auch dieser neue Feed jedem Nachbarbroker entsprechend den vorhandenen
Filterregeln übersand; jeder Nachbarbroker leitet seinerseits diesen neuen Feed an die jeweiligen Nachbarbroker weiter,
falls der Feed hier ebenfalls aktueller ist als der bisherige. Allerdings
wird der Poll-Timer nur in diesem Fall neu gesetzt. Das setzen des Poll-Timers geschieht folgendermaßen: Aus ``lastBuildDate'' und ``minUpdateInterval''
wird die ungefähre Zeitspanne ``nextAktualisation'' zur nächsten Aktualisierung durch den Publisher berechnet. Für den Wert des Poll-Timers $pt$ soll
nun gelten: $nextAktualisation \leq pt \leq 2*nextAktualisation$. $pt$ wird in diesem Bereich zufällig gewählt. Somit sollte es relativ wenige Broker
geben, die gleichzeitig den aktuellen Stand beim Publisher erfragen. Nach erfolgreicher Aktualisierung wird mit hoher Wahrscheinlichkeit ein anderer Broker
den Stand beim nächsten Mal erfragen. Außerdem ist gewährleistet, dass bei hoher Brokerzahl nach Ablauf der Poll-Timer in regelmäßigen Abständen der
Publisher kontaktiert wird, falls zu diesem Zeitpunkt noch keine Aktualisierung vorlag.\\
Tritt ein neuer Knoten dem Netzwerk bei, so wird dieser den aktuellen Stand bei seinem nächsten Nachbarn erfragen.

\end{document}
