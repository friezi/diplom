\section{Koordinierung der Subscriber}
\todo{Literaturangaben}\\
\todo{Auflistung der Anforderungen an den Algorithmus}\\
Um das Netz nicht noch zusätzlich zu belasten, sollte der Overhead, der durch eventuelle Abstimmungsnachrichten entsteht, minimal sein.
Die Konzeption eines Algorithmus sollte unter folgenden Gesichtspunkten erfolgen:
\begin{itemize}
  \item Polling durch mehrere bzw. wechselnde Klienten
  \item Anfragen an den RSS-Server sollten nicht gleichzeitig für alle Klienten geschehen 
  \item Ausfall von Klienten im Overlaynetzwerk soll Informationsverteilung nicht blockieren
  \item Overhead durch Abstimmungsnachrichten sollte gering gehalten werden
\end{itemize} 
Im Folgenden beschreiben wir einen Algorithmus bzw. eine Technik, die unsere bisher gestellten Anforderungen erfüllt.
\subsubsection*{Der Grundlegende Algorithmus}
Es sei $t_0$ immer der aktuelle Zeitpunkt. Ausgehend von einem beliebigen Zeitpunkt
$t_x$ mit $t_0\leq t_x$ und einer Intervallspanne $\Delta I$ wählt sich jeder Subscriber $i$ innerhalb
des Zeitintervalls $I:=[t_x,t_x+\Delta I]$ einen zufälligen Zeitpunkt $TTR_i$ (TimeToRefresh, $TTR$ im allgemeinen), zu dem
er den aktuellen Feed vom RSS-Server erfragt (siehe Abb. \ref{Abb:determine_ttr}).

\begin{picturehere}{3}{1.5}{$TTR$s}{Abb:determine_ttr}
 
%\psset{xunit=1cm,yunit=1cm,runit=1cm}
%\begin{picture}(1.5,-0.5)(7,1)
\begin{picture}(7,1)(1.5,-0.5)
  \put(0,0){\vector(1,0){7}}
  \put(0,-0.2){\line(0,1){0.4}}
  \put(0,-0.5){$t_0$}
  \put(3,-0.2){\line(0,1){0.4}}
  \put(3,-0.5){$t_x$}
  \put(6,-0.2){\line(0,1){0.4}}
  \put(6,-0.5){$t_x+\Delta I$}
  \put(5,-0.1){\line(0,1){0.2}}
  \put(4.5,0.4){$TTR_i$}
  \put(7.8,0){$time$}
\end{picture}
% \includegraphics{determine_ttr}
\end{picturehere}


Ist $TTR_i$ erreicht, so erfragt Subscriber $i$ den aktuellen Feed vom RSS-Server und setzt nun $TTR_i$ auf einen
Zufallswert innerhalb des
Zeitintervalls $I:=[t_x,t_x+\Delta I]$, wobei $t_x$ ebenfalls neu gewählt wird.
Erhält Subscriber $i$ vor dem Erreichen des Zeitpunktes $TTR_i$ einen Feed $feed_{new}$ von einem Broker zum 
Zeitpunkt $t_f$ (sei $feed_{old}$ der bisher bei $i$ gespeicherte Feed), so geschieht folgendes:
\pagebreak[3]
\begin{description}
  \item [Fall I:] $feed_{new}$ ist nicht aktueller als $feed_{old}$:
    \begin{description}
      \item keine Änderungen
    \end{description}
  \item[Fall II:] $feed_{new}$ ist aktueller als $feed_{old}$:
    \begin{description}
      \item wähle $t_x$ neu mit $t_0\leq t_x$
      \item  $TTR_i$ wird auf einen Zufallswert gesetzt innerhalb des Zeitintervalls
        $I:=[t_x,t_x+\Delta I]$
    \end{description}
\end{description}

Die $TTR$s der verschiedenen Subscriber sollten bei der Wahl einer geeigneten Zufallsfunktion über $I$ gleichmäßig
verteilt sein. Durch die Wahl eines zufälligen Wertes innerhalb von $I$ ist gewährleistet, dass nur in extremen Ausnahmefällen (theoretisch) 
alle Klienten gleichzeitig den RSS-Server kontaktieren.  Natürlich kann es vorkommen, dass $TTR$s verschiedener
Subscriber auf den gleichen Zeitpunkt fallen (je nach Größe der Intervallspanne $\Delta I$ und der Anzahl der Klienten).
Die Verteilung unterliegt jedoch einem kontinuierlichen Wechsel, da die $TTR$s immer
wieder neu berechnet werden. $\Delta I$ bildet eine obere Schranke für den Erhalt des nächsten Feeds, da jeder Klient nach
spätestens $\Delta I$ selbständig den Server kontaktiert, falls in der Zwischenzeit kein aktueller Feed erhalten wurde. Dadurch können lange
Übertragungszeiten zwischen den Klienten ausgeglichen werden.
Ausfälle von Klienten können zwar zu Verzögerungen beim
Erhalt der Feeds führen, sie können aber die Übermittlung der Feeds zwischen den übrigen Klienten nicht stören,
solange nicht das Sublayer betroffen ist und das Brokernetz intakt ist.
\subsubsection*{Konkrete Anpassung an RSS}
Die Frage ist, wie sich $t_x$ bestimmt. Lässt sich der Zeitpunkt $nextBuild$, zu dem der RSS-Server einen neuen Feed
bereitstellt, innerhalb eines gewissen Toleranzbereiches genau bestimmen, dann können wir $t_x:=nextBuild$ setzen. Kann
$nextBuild$ innerhalb des gewünschten Toleranzbereiches nicht genau bestimmt werden, kann es nötig sein $t_x:=t_0$ zu setzen. Unter welchen
Umständen welche Variante vorzuziehen ist, werden wir später noch erörtern.
\subsubsection*{Bestimmung von $nextBuild$}
Es gibt verschiedene Möglichkeiten $nextBuild$ zu bestimmen:
\paragraph{Server-seitig unterstützte Bestimmung:}
Der RSS 2.0 Standard\cite{RSSSpecWi2004} sieht einige sehr hilfreiche optionale Parameter vor: $TTL$, $lastBuildDate$ und $pubDate$
(Beschreibung siehe Kapitel\ref{ch_rss} auf Seite \pageref{op_rss}). Falls der RSS-Server diese Parameter unterstützt, lässt sich
$nextBuild$ aufgrund des letzten aktuellen Feeds wie folgt berechnen:
\[nextBuild:=t_0+\Delta t\] mit \[\Delta t:=\left\{\begin{array}{r@{\quad:\quad}l}
    0 & (t_0-lastBuildDate)>TTL \\TTL-(t_0-lastBuildDate) & sonst
  \end{array}\right. \]

Ob es aus Sicht des Informationsanbieters Sinn macht, diese optionalen Parameter bereitzustellen, hängt von der Vorhersagbarkeit des Auftretens
neuer Daten und der zeiltichen Möglichkeit, diese Daten bereit zu stellen, ab. Beispielsweise ist das Auftreten von Ereignissen des
aktuellen Tagesgeschehens mit Sicherheit nicht vorhersagbar. Werden diese zum Zeitpunkt der Berichterstattung bereitgestellt, so wird
es sicherlich wenig Sinn machen, den Parameter $TTL$ zu definieren, da nicht vorherbestimmt werden kann, wann neue Ereignisse eintreten. Ein
Betreiber einer Webseite, der täglich sein Tagebuch veröffentlicht, könnte diesen Parameter jedoch mitliefern, wenn er z.B. immer um Punkt
10 Uhr seine Webseite aktualisiert.

\paragraph{Bestimmung durch den Klienten}:
Wird der Parameter $TTL$ vom Betreiber nicht unterstützt, so kann $nextBuild$ heuristisch bestimmt werden. Hierzu gibt es verschiedene
Verfahren, von denen wir zwei vorstellen wollen.\todo{Bestimmung des TTL}


