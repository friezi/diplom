\section{Koordinierung der Subscriber}
\todo{Literaturangaben}\\

Um das Netz nicht noch zusätzlich zu belasten, sollte der Overhead, der durch eventuelle Abstimmungsnachrichten entsteht, minimal sein.
Die Konzeption eines Algorithmus sollte unter folgenden Gesichtspunkten erfolgen:
\begin{itemize}
  \item Polling durch mehrere bzw. wechselnde Klienten
  \item Anfragen an den RSS-Server sollten nicht gleichzeitig für alle Klienten geschehen 
  \item Ausfall von Klienten im Overlaynetzwerk soll Informationsverteilung nicht blockieren
  \item Overhead durch Abstimmungsnachrichten sollte gering gehalten werden
\end{itemize} 
Im Folgenden beschreiben wir einen Algorithmus bzw. eine Technik, die unsere bisher gestellten Anforderungen erfüllt.
\subsubsection*{Der Grundlegende Algorithmus}
Es sei $t_0$ immer der aktuelle Zeitpunkt. Ausgehend von einem beliebigen Zeitpunkt
$t_x$ mit $t_0\leq t_x$ und einer Intervallspanne $\Delta I$ wählt sich jeder Subscriber $i$ innerhalb
des Zeitintervalls $I:=[t_x,t_x+\Delta I]$ einen zufälligen Zeitpunkt $TTR_i$ (TimeToRefresh, $TTR$ im allgemeinen), zu dem
er den aktuellen Feed vom RSS-Server erfragt (siehe Abb. \ref{Abb:determine_ttr}).

\begin{picturehere}{3}{1.5}{$TTR$s}{Abb:determine_ttr}
 
%\psset{xunit=1cm,yunit=1cm,runit=1cm}
%\begin{picture}(1.5,-0.5)(7,1)
\begin{picture}(7,1)(1.5,-0.5)
  \put(0,0){\vector(1,0){7}}
  \put(0,-0.2){\line(0,1){0.4}}
  \put(0,-0.5){$t_0$}
  \put(3,-0.2){\line(0,1){0.4}}
  \put(3,-0.5){$t_x$}
  \put(6,-0.2){\line(0,1){0.4}}
  \put(6,-0.5){$t_x+\Delta I$}
  \put(5,-0.1){\line(0,1){0.2}}
  \put(4.5,0.4){$TTR_i$}
  \put(7.8,0){$time$}
\end{picture}
% \includegraphics{determine_ttr}
\end{picturehere}


Ist $TTR_i$ erreicht, so erfragt Subscriber $i$ den aktuellen Feed vom RSS-Server und setzt nun $TTR_i$ auf einen
Zufallswert innerhalb des
Zeitintervalls $I:=[t_x,t_x+\Delta I]$, wobei $t_x$ ebenfalls neu gewählt wird.
Erhält Subscriber $i$ vor dem Erreichen des Zeitpunktes $TTR_i$ einen Feed $feed_{new}$ von einem Broker zum 
Zeitpunkt $t_f$ (sei $feed_{old}$ der bisher bei $i$ gespeicherte Feed), so geschieht folgendes:
\pagebreak[3]
\begin{description}
  \item [Fall I:] $feed_{new}$ ist nicht aktueller als $feed_{old}$:
    \begin{description}
      \item keine Änderungen
    \end{description}
  \item[Fall II:] $feed_{new}$ ist aktueller als $feed_{old}$:
    \begin{description}
      \item wähle $t_x$ neu mit $t_0\leq t_x$
      \item  $TTR_i$ wird auf einen Zufallswert gesetzt innerhalb des Zeitintervalls
        $I:=[t_x,t_x+\Delta I]$
    \end{description}
\end{description}

Die $TTR$s der verschiedenen Subscriber sollten bei der Wahl einer geeigneten Zufallsfunktion über $I$ gleichmäßig
verteilt sein. Durch die Wahl eines zufälligen Wertes innerhalb von $I$ ist gewährleistet, dass nur in extremen Ausnahmefällen (theoretisch) 
alle Klienten gleichzeitig den RSS-Server kontaktieren.  Natürlich kann es vorkommen, dass $TTR$s verschiedener
Subscriber auf den gleichen Zeitpunkt fallen (je nach Größe der Intervallspanne $\Delta I$ und der Anzahl der Klienten).
Die Verteilung unterliegt jedoch einem kontinuierlichen Wechsel, da die $TTR$s immer
wieder neu berechnet werden. $\Delta I$ bildet eine obere Schranke für den Erhalt des nächsten Feeds, da jeder Klient nach
spätestens $\Delta I$ selbständig den Server kontaktiert, falls in der Zwischenzeit kein aktueller Feed erhalten wurde. Dadurch können lange
Übertragungszeiten zwischen den Klienten ausgeglichen werden.
Ausfälle von Klienten können zwar zu Verzögerungen beim
Erhalt der Feeds führen, sie können aber die Übermittlung der Feeds zwischen den übrigen Klienten nicht stören,
solange nicht das Sublayer betroffen ist und das Brokernetz intakt ist.
\subsubsection*{Konkrete Anpassung an RSS}
Die Frage ist, wie sich $t_x$ bestimmt. Lässt sich der Zeitpunkt $nextBuild$, zu dem der RSS-Server einen neuen Feed
bereitstellt, innerhalb eines gewissen Toleranzbereiches genau bestimmen, dann können wir $t_x:=nextBuild$ setzen. Kann
$nextBuild$ innerhalb des gewünschten Toleranzbereiches nicht genau bestimmt werden, kann es nötig sein $t_x:=t_0$ zu setzen. Unter welchen
Umständen welche Variante vorzuziehen ist, werden wir später noch erörtern.
\subsubsection*{Bestimmung von $nextBuild$}
Um $nextBuild$ zu bestimmen, definieren wir zwei weitere Parameter: $ttl$ und $lastBuildDate$. $ttl$ steht für ``time to live'' und bezeichnet
die Anzahl Minuten, die ein Feed aktuell bleibt, bevor er server-seitig aktualisiert wird. $lastBuildDate$ steht für den Zeitpunkt, zu dem ein
Feed vom Server aktualisiert wurde.
Der RSS 2.0 Standard\cite{RSSSpecWi2004} sieht unter anderem die optionalen Parameter $lastBuildDate$ und $pubDate$ vor. Setzen wir voraus,
dass mindestens der Parameter $lastBuildDate$ vom Server bereitgestellt wird.
(Beschreibung siehe Kapitel \ref{ch_rss} auf Seite \pageref{op_rss}). $nextBuild$ lässt sich
aufgrund des letzten aktuellen Feeds wie folgt berechnen:
\[nextBuild:=t_0+\Delta t\] mit \[\Delta t:=\left\{\begin{array}{r@{\quad:\quad}l}
    0 & (t_0-lastBuildDate)>ttl \\ttl-(t_0-lastBuildDate) & sonst
  \end{array}\right. \]

Alternativ könnte statt $lastBuilddate$ auch $pubDate$ zur Berechnung genommen werden. Um $ttl$ zu bestimmen, gibt es zwei Möglichkeiten.

\paragraph{Bereitstellung des $ttl$ durch den Informationsanbieter:}
RSS 2.0\cite{RSSSpecWi2004} sieht ebenfalls den optionalen Parameter $ttl$ vor.
Ob es aus Sicht des Informationsanbieters Sinn macht, diesen optionalen Parameter bereitzustellen, hängt von der Vorhersagbarkeit des Auftretens
neuer Daten und der zeitlichen Möglichkeit, diese Daten bereit zu stellen, ab. Beispielsweise ist das Auftreten von Ereignissen des
aktuellen Tagesgeschehens mit Sicherheit nicht vorhersagbar. Werden diese zum Zeitpunkt der Berichterstattung bereitgestellt, so wird
es sicherlich wenig Sinn machen, den Parameter $ttl$ zu definieren, da nicht vorherbestimmt werden kann, wann neue Ereignisse eintreten. Ein
Betreiber einer Webseite jedoch, der täglich sein Tagebuch veröffentlicht, könnte diesen Parameter mitliefern, wenn er z.B. immer um Punkt
10 Uhr seine Webseite aktualisiert.

\paragraph{Bestimmung des $ttl$ durch den Klienten:}
Wird der Parameter $ttl$ vom Informationsanbieter nicht unterstützt, so kann $ttl$ heuristisch durch den Klienten bestimmt werden.
Hierzu gibt es verschiedene Verfahren, von denen wir eines vorstellen wollen.
Cho und Garcia-Molina beschreiben in \cite{ChGM:2003:ChangeFrequency} eine Methode zur Bestimmung der Update-Frequenz mit besseren
Eigenschaften als die naive Methode.


