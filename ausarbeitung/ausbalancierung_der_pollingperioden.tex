\subsection{Ausbalancierung der Polling-Perioden}
\label{cs:ausbalancierung_der_polling-perioden}
Wie wir schon in Abschnitt \ref{cssp:ung_u_probl:dysbalance} auf Seite \pageref{cssp:ung_u_probl:dysbalance} beschrieben haben, kann es vorkommen, dass Subscriber
aufgrund von Dysbalancen der Polling-Perioden im System ``ausgesperrt'' werden: Subscriber, deren Polling-Periode sehr niedrig ist, haben fast ausschließlichen
Zugriff auf den Server, während sich die Polling-Perioden der übrigen Subscriber stetig vergrößern, da ihre Anfragen keinen Zugang zur Server-Queue
finden. Um diesem Problem beizukommen, müssen bei Dysbalancen im System Subscriber mit niedrigen Polling-Perioden diese erhöhen, während Subscriber mit hohen
Polling-Perioden Gelegenheit bekommen müssen, diese zu erniedrigen.\\

Um dieses Ziel zu erreichen, verwenden wir folgendes Verfahren: speist ein Subscriber einen RSS-Feed in das Notifikationssystem ein (er sendet den Feed an den
ihm zugewiesenen Broker), so übermittelt er als zusätzliches Attribut den von ihm gemessenen $artt$. Erhält ein Subscriber einen RSS-Feed vom Notifikationssystem,
so stellt sein neuer $artt$-Wert den Mittelwert aus seinem eigenen $artt$ und dem übermitteltem $artt$ (im Folgenden nennen wir ihn $feed.artt$) dar, also:
\begin{equation}
  artt:=\frac{artt+feed.artt}{2}
\end{equation}
Es handelt sich dabei um ein kooperatives Modell: die gegenseitige Unterstützung der Subscriber wird vorausgesetzt, ein gemeinsames Ziel verlangt die Einschränkung
des Einzelnen.
\paragraph{Auswirkungen:}
Das Verfahren führt dazu, dass Subscriber mit einer langen Polling-Periode, die einen Feed mit einem niedrigen $artt$ erhalten, ihre Polling-Periode senken,
allerdings nicht auf das Niveau des Subscribers, welcher den Feed ausgesandt hat. Somit wird eine zu schnelle Überlastung des Systems vermieden.
Im Gegenzug wird ein Subscriber mit einer gesenkten Polling-Periode schneller in den Genuss einer Server-Antwort kommen, so dass er ebenfalls einen Feed mit
seinem noch relativ hohen $artt$ in das Notifikationssystem einspeisen kann. Das führt dazu, dass Subscriber mit einer niedrigen Polling-Periode diese bei Erhalt
jenes Feeds erhöhen.\\

Dies hat noch einen weiteren positiven Nebeneffekt: angenommen, alle Subscriber haben eine lange Polling-Periode aufgrund einer länger anhaltenden Server-Überlastung
eingestellt. Kommt es zu einer plötzlichen Reaktionsfreudigkeit des Servers, so wird der erste Subscriber, der diese feststellt, nicht nur seine Polling-Periode
entsprechend anpassen, sondern alle anderen Subscriber, die die Ansprechbarkeit des Servers nicht bemerkt haben, mitziehen. Ein plötzlicher übermäßiger Ansturm auf
den Server sollte aber ausbleiben, da die übrigen Subscriber ihre Polling-Perioden nicht drastisch, sondern nur allmählich senken. Die Subscriber, welche ihre
Polling-Periode drastisch gesenkt haben, werden gezwungen sein, ihre Polling-Periode wieder anzuheben. Dadurch erwarten wir eine homogenere Adaption der
Polling-Perioden an die Server-Auslastung.\\
Bei einer plötzlichen Server-Überlastung wird das jeder Subscriber schnell mitbekommen, weswegen sich in diesem Fall nicht viel ändert.\\

Dadurch, dass der Wert $artt$ und nicht der Wert $cpp$ übermittelt wird, kann jeder Subscriber seinen individuellen $cpp$-Wert entsprechend seiner Voreinstellungen
($ppp$) unabhängig der Voreinstellungen anderer Subscriber berechnen.\\

Die Wirksamkeit der ausbalancierenden Methode gegenüber der nicht-ausbalancierenden Methode wird mit Hilfe der selbst entwickelten Simulationsumgebung gezeigt,
die Ergebnisse sind in Kapitel \ref{c:experimente} zusammengetragen.\\

Listen wir die Vorteile und möglichen Nachteile dieser Methode auf:
\begin{itemize}
\item Vorteile
  \begin{itemize}
  \item Polling-Perioden werden ausbalanciert
  \item Bei unbemerkter Veränderung der Serverbelastung werden Subscriber mitgezogen
  \item Ansturm auf Server wird vermieden
  \end{itemize}
\item Nachteile
  \begin{itemize}
  \item Kooperatives Modell erfordert kooperatives Verhalten: spielen einige Subscriber nicht mit, wird die Idee des Systems untergraben. Das System kann nicht
    mehr in der gewünschten Weise funktionieren.
  \end{itemize}
\end{itemize}

Das Verfahren erfordert auf der Ebene des Notifikationssystems eine neue Datenstruktur, um den neu hinzugekommenen Wert $artt$ aufzunehmen. Folgende auf Java-Syntax
beruhende Datenstruktur ist denkbar:

\begin{verbatim}
class RichRSSFeed extends RSSFeed{

    long artt;

}

\end{verbatim}

Nun muss bei jedem Erhalt eines RSS-Feeds der $cpp$ angepasst werden. Damit ein Subscriber zu jedem Zeitpunkt den derzeitigen Stand der gemessenen roundtrip-time
mitteilen kann, müssen nun jedesmal, wenn $RT$ abläuft, $rtt:=rto$ gesetzt und $artt$ neu berechnet werden.
Dafür ist es notwendig, die Methoden zur Aktualisierung des $RQT$ anzupassen.\\

Auch hierbei können gewisse Probleme und Seiteneffekte auftreten, die wir im Folgenden mitsamt Lösungen beschreiben.

\paragraph{$RQT$ verhindert Anfragen:}
Erhält ein Subscriber immer neue Feeds über das Notifikationssystem, bevor sein $RQT$ abgelaufen ist, so wird der $RQT$ ständig neu gesetzt, so dass
eine eigenmächtige Aussendung eines Feed-Requests durch den Subscriber ausbleibt. Der Subscriber nimmt an der Versorgung des Notifikationssystems mit RSS-Feeds
nicht mehr aktiv Teil. Um hier Abhilfe zu schaffen, setzen wir den $RQT$ nur dann neu, wenn durch den neu gesetzten $RQT$ der anstehende Feed-Request früher
ausgesendet werden würde. Ansonsten kommt der neue
$cpp$ erst bei der nächsten Runde in Betracht.

\paragraph{Beeinflussung des $cpp$:}
Was soll passieren, wenn ein Subscriber einen Feed über das Notifikationssystem erhält, während schon mehrfache Wiederholungen auftraten und der Subscriber
sich bei laufendem $RT$ gerade in der Messung der roundtrip-time befindet? Die Messung und die Wiederholungen sollten natürlich weiter laufen.
Nach unserem bisherigen Konzept hat der übermittelte $feed.artt$ keinen Einfluss auf die zeitliche Abfolge wiederholter Anfragen.
Ist der Wert des übermittelten $feed.artt$ größer als der $artt$-Wert des Empfängers zu Beginn der Messung, so ist dies ein akzeptables Verhalten,
denn der Wert des übermittelten $feed.artt$ könnte aufgrund verloren gegangener Feed-Requests bestimmt worden sein und an der tatsächlichen roundtrip-time
vorbei gehen. Der empfangende
Subscriber hat noch die Möglichkeit, eine aussagekräftigere roundtrip-time zu bestimmen. Ist $feed.artt$ jedoch kleiner als der $artt$-Wert des Empfängers
zu Beginn der Messung, so wäre eine Einflussnahme von Vorteil, da der Wert des $feed.artt$ vermutlich aussagekräftiger ist. Denn entweder wurden weniger
Wiederholungen benötigt, um diesen zu
ermitteln, oder die Abtastrate (sprich die Rate der Feed-Requests) war höher. Um dieses Verhalten zu ermöglichen, müssen wir einen neuen Wert definieren,
den $icpp$ (für initial-cpp), welcher als
Berechnungsgrundlage für $rto$ dienen soll und den $cpp$ in diesem Zusammenhang ersetzt. Bei jedem Setzen des $RQT$ wird $icpp$ auf
$icpp:=cpp$ gesetzt. Die Berechnung von $rto$ erfolgt dann nach jeder Aussendung einer Anfrage wie folgt:
\begin{equation}
rto:=2^i\cdot icpp
\end{equation}
Hierbei ist $i$ ebenfalls die Anzahl der Anfragen bzw. Verbindungsversuche.\\

Während einer Messung der roundtrip-time kann der $cpp$ modifiziert werden, ohne dass dies einen Einfluss auf den $rto$ hat.
Da nach Abschluss der Messung $artt$ und somit $cpp$ neu berechnet werden, hat letztlich in diesem Fall die Übermittlung des $artt$ eines anderen Subscribers
keinen Einfluss auf den $artt$-Wert des empfangenden Subscribers. Im dem Fall jedoch, dass $feed.artt$ kleiner als der $artt$-Wert zu Beginn der Messung ist
(gilt dann, wenn $cpp<icpp$, da $cpp$ schon aufgrund des $feed.artt$-Wertes neu berechnet wurde), setzen wir $icpp:=cpp$.
Würden wir diese Modifikation nicht vornehmen, hätte in diesem Fall keine Ausbalancierung stattgefunden.\\

Unsere Algorithmen müssen wir also wie folgt modifizieren und vervollständigen\footnote{Die Unterstriche kennzeichnen die neu hinzugekommenen Funktionen bzw.
Aufrufe.}:

\lstset{language=Java,emph={setze_icpp,berechne_mittleren_artt},emphstyle=\underbar}
\begin{lstlisting}

berechne_mittleren_artt(Feed feed){

    setze_artt((feed.artt + artt) / 2);
    setze_cpp(artt);

    if ( cpp < icpp )
      setze_icpp(cpp);

}

aktualisiere_RQT_durch_alten_Brokerfeed {

    berechne_mittleren_artt(feed);

    if ( RT_läuft_nicht ){

      berechne_delta_ttr(cpp);
      if ( delta_ttr < RQT.Zeitdifferenz_bis_ablauf )
        setze_RQT(delta_ttr);

    }

}

aktualisiere_RQT_durch_neuen_Brokerfeed {

    berechne_mittleren_artt(feed);

    berechne_delta_ttr(cpp);
    if ( delta_ttr < RQT.Zeitdifferenz_bis_ablauf )
      setze_RQT(delta_ttr);

}

aktualisiere_RQT_durch_alten_Serverfeed {

    berechne_rtt();
    berechne_artt();
    setze_cpp(artt);
    setze_icpp(cpp);
    stoppe_RT();
    setze_rto_zurück();
    setze_RQT(cpp);

}

aktualisiere_RQT_durch_neuen_Serverfeed {

    berechne_rtt();
    berechne_artt();
    setze_cpp(artt);
    setze_icpp(cpp);
    stoppe_RT();
    setze_rto_zurück();
    berechne_delta_ttr(cpp);
    setze_RQT(delta_ttr);

}

\end{lstlisting}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "diplomarbeit"
%%% End: 
