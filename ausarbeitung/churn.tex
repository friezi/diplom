\subsection{Churn}
\label{cs:churn}
Bei allen Peer-To-Peer-Systemen tritt ein Phänomen auf, welches als ``Churn'' bezeichnet wird: das dynamische Zu- und Abwandern von Klienten bzw. Knoten. In
Peer-To-Peer-Systemen spielen die Klienten eine entscheidende Rolle. In fast allen diesen Systemen kommunizieren die Klienten direkt miteinander, um Daten
auszutauschen oder wichtige Informationen zu liefern (z. B. Dateien oder Routing-Informationen). Je nach Struktur des Peer-To-Peer-Netzes kann die plötzliche
Abwesenheit von beteiligten Knoten zu Beeinträchtigungen oder gar Fehlfunktionen des Systems führen. Während unstrukturierte Peer-To-Peer-Netze Churn zum Teil
gut verkraften können, können strukturierte Peer-To-Peer-Netze (z. B. DHTs) mit Churn nicht anstandslos umgehen, bzw. benötigen spezielle Mechanismen, um den
Einflüssen von Churn entgegenzuwirken \cite{Stutzbach2004}.\\

\paragraph{Auswirkungen:}
Die Auswirkungen von Churn können verschiedenartig sein. So kann Churn beispielsweise bei BitTorrent dazu führen, dass sich Downloadzeiten verlängern, falls
Klienten das System verlassen, oder dass bestimmte Dateien nicht zugreifbar sind, falls ein Tracker ausfällt. Bei DHT-basierten Netzen (neuere BitTorrent-Versionen
sind mittlerweile DHT-basiert) kann schon ein
vorüber\-gehen\-der Verlust eines Nachbarknoten zu Performanzeinbußen führen (Effizienz ist ein Designziel bei DHT), da der Ausgangsknoten gezwungen ist,
suboptimale Routen zu wählen \cite{Rhea2004}. Dabei erhöht sich die Wahrscheinlichkeit zukünftiger Ausfälle des Systems.

\paragraph{Messung:}
Um Churn messen zu können, ist eine Metrik erforderlich, die über Zu- und Abwanderung Auskunft gibt. Es bietet sich an, die Zeit zwischen Betreten und Verlassen
des Systems durch einen Knoten zu messen. Beobachtungen haben gezeigt, dass sich die durchschnittlichen Zeiten zwischen einer Stunde und einigen Minuten bewegen
können \cite{Rhea2004}. Stutzbach und Rejaie \cite{Stutzbach2004} haben eine Reihe von Techniken entwickelt und in einem von ihnen entwickelten Tool ($Cruiser$)
vereint, um das Gnutella-Netzwerk in relativ kurzer Zeit zu durchforsten und einen aktuellen Schnappschuss (``Snapshot'') der Gnutella-Population zu erhalten. Wie
Stutzbach und Rejaie feststellen, ist das Gnutella-Netzwerk ein sehr großes Peer-To-Peer-Netzwerk bestehend aus hunderttausenden von heterogenen und
geographisch verteilten Peers. Darüber hinaus wird jeder User-Client-Prozess direkt durch einen Benutzer gesteuert. Das heißt das ``Verhalten der User-Clients
repräsentiert vollständig Benutzer-gesteuerte Aspekte dynamischer Mitgliedschaften'' im System \cite{Stutzbach2004}. Ergebnisse einer solchen Untersuchung können
damit für Peer-To-Peer-Systeme auf gleicher Basis herangezogen werden. Nach Stutzbach und Rejaie entspricht die Verteilung der Zeitwerte, die sich Benutzer im
System befinden, nicht, wie bisher angenommen, einer Poisson-Verteilung, sondern einer Exponentialverteilung.

\paragraph{Gegenmaßnahmen:}
Um den Auswirkungen von Churn entgegen zu wirken, wurden einige Techniken in Abhängigkeit von der zugrunde liegenden Netzwerkstruktur entwickelt. Mit
Churn-Kompensation bei CMR-basierten Netzen (``Concentric Multi-ring Overlay'') beschäftigen sich Wepiw\'e und Albayrak in \cite{Giscard2006}, Rhea et al.
in \cite{Rhea2004} bei DHT-basierten Netzen. Ziel der beschriebenen Verfahren ist es, das Netzwerk in einem konsistenten Zustand zu halten bzw. das Netzwerk
schnell in einen solchen wieder zurückzuführen.

\paragraph{Auswirkungen von Churn auf \pubsubrss:}
Verlassen einzelne Broker das Netzwerk, so kann man sich sehr leicht vorstellen, welche Auswirkungen das auf das Gesamtsystem hat: da das Brokersystem in einer
baumartigen Struktur aufgebaut ist, bedeutet der Verlust einzelner Broker ein Auseinanderfallen des Baumes in mehrere unabhängige Teilbäume. Während das Erfragen
von RSS-Feeds durch Subscriber und das Messen der Roundtrip-Times weiterhin vonstatten gehen kann, können zwischen den Teilbäumen keine Nachrichten mehr
ausgetauscht werden. Je größer also der Zerfall ist, desto geringer wird der Aktualitätsgrad der RSS-Feeds sein und desto länger dauert eine Anpassung der
Polling-Perioden der Subscriber an eine veränderte Server-Belastung, da eine Ausbalancierung der Polling-Perioden in immer geringerem Maße erfolgen wird.\\
Welche Knoten in einem Netzwerk die Rolle der Broker übernehmen, bleibt zunächst offen. Ob Broker das System benutzergesteuert verlassen können, hängt ganz von der
jeweiligen Umsetzung des Systems ab. Denkbar sind beispielsweise dedizierte Knoten, welche dauerhaft online sind und kaum Ausfallerscheinungen aufweisen. Deshalb
wollen wir hier auf eine mögliche Kompensation von Churn bei Brokern nicht eingehen.\\

Da in \pubsubrss Subscriber nicht direkt mit einander kommunizieren, hat Churn keinerlei Auswirkung auf die Übertragungsgeschwindigkeit von Daten noch auf die
Erreichbarkeit einzelner Daten (Feeds).\\
Verlassen Subscriber das System, so hat das weniger Feed-Requests pro Zeiteinheit zur Folge, woraufhin die übrigen
Subscriber ihre Polling-Perioden erniedrigen werden. Dies ist kein nachteiliger Effekt.\\
Beim Eintreten von Subscribern in das System stellen diese zunächst ihren
$cpp$ auf den von ihnen gewählten $ppp$ ein. Erst im Laufe der Messung der Roundtrip-Times werden diese Subscriber ihren $cpp$ erhöhen. Bei einer hohen Anzahl von
pro Zeiteinheit neu in das System hinzukommenden Subscribern gibt es also eine erhöhte Rate an Feed-Requests. Dies bedeutet eine Mehrbelastung des jeweiligen
RSS-Servers. Egal, wie gut die Anpassung an die Server-Belastung von statten geht: die Mehrbelastung ist in diesem Fall einzig und allein abhängig von der
Churn-Rate.

\subsubsection{Churn-Kompensation bei \pubsubrss}
Um die negativen Auswirkungen von Churn bei \pubsubrss zu reduzieren, muss also die Mehrbelastung des Servers durch neu hinzugekommene Subscriber so weit wie möglich
vermieden werden. Dabei hilft uns folgende Idee: tritt ein Subscriber dem System bei, so existieren eventuell schon genügend Subscriber, welche einen
aussagekräftigen $rtt$ und $cpp$ berechnet haben. der neu hinzugekommene Subscriber kann sich also an diesen Richtwerten orientieren. Es wäre mit einigem Aufwand
verbunden, die Anzahl der Subscriber im gesamten Netzwerk zu bestimmen. Es reicht jedoch aus, die Anzahl der Subscriber heranzuziehen, welche mit dem gleichen
lokalen Broker verbunden sind. Diese Information kann der lokale Broker ohne Schwierigkeiten liefern. Da den Broker nur $RichRSSFeeds$ passieren (siehe Abschnitt
\ref{cs:ausbalancierung_der_polling-perioden}), kann dieser den entahltenen $feed.rtt$ zwischenspeichern. Betritt nun ein neuer Subscriber das System, so kann
der Broker diesem den aktuellen Feed mitsamt des zwischengespeicherten $rtt$ übermitteln. Der neue Subscriber wählt nun wie bisher seinen $cpp$ auf Basis dieses
$feed.rtt$. Dadurch steigen neue Subscriber bei der Messung der Roundtrip-Time bereits auf einem höheren Niveau ein, wovon wir uns eine Entlastung des RSS-Servers
versprechen. Experimente und ihre Auswirkung zu diesem Punkt folgen in Kapitel \ref{c:experimente}.\\
Um dieses Verfahren zu realisieren, müssen wir eine zusätzliche Datenstruktur und zusätzliche Methoden zu unseren schon bestehenden hinzufügen:

\begin{verbatim}

public class InitialBrokerRSSFeed extends RSSFeed {

        zahl_lokaler_subscriber;
        rtt;

}

speichere_initiale_borkerinformationen(InitialBrokerRSSFeed feed) {

        if ( feed.zahl_lokaler_subscriber < 2 )
          return;

        if ( feed.rtt < 1 )
          return;

        setze_rtt(feed.rtt);
        setze_cpp(rtt);
        setze_icpp(cpp);

        aktualisiere_RQT_durch_initialen_brokerfeed();

}

aktualisiere_RQT_durch_initialen_brokerfeed() {

        berechne_delta_ttr(cpp);
        setze_RQT(delta_ttr);

}

\end{verbatim}

